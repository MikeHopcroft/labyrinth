import {RoutingRuleSpec} from '../../graph';

import {AzureVirtualNetwork} from './azure_types';
import {
  AzureBackboneFriendlyName,
  AzureBackboneKeyName,
  SuffixOutbound,
} from './constants';
import {GraphServices} from './graph_services';

///////////////////////////////////////////////////////////////////////////////
//
// convertResourceGraph() is responsible for
//   1. Creating the `Internet` node with routes to all public ips.
//   2. Materializing root nodes for VNets, NICs, and possibly compute pools.
//   3. Defining the `Internet` service tag, which is referenced by routing
//      and filtering rules in VNets and NSGs.
//
///////////////////////////////////////////////////////////////////////////////
export function convertResourceGraph(services: GraphServices) {
  // The Azure resource graph is considered to be a forest of AnyAzureObjects,
  // some of which are AzureVirtualNetworks.

  // TODO: Allocate internetNodeKey to avoid possible collisions
  const internetFriendlyName = 'Internet';
  const internetBackboneKey = 'Internet-Backbone';
  const internetEndpointKey = 'Internet';
  const internetServiceTag = services.getInternetServiceTag();

  const backboneOutboundKey = services.nodes.createKeyVariant(
    AzureBackboneKeyName,
    SuffixOutbound
  );

  //
  // Materialize each public ip.
  //

  const internetRoutes: RoutingRuleSpec[] = [];
  const backboneOutboundRoutes: RoutingRuleSpec[] = [];

  // Materialize each virtual network, while saving its NodeKey for later use.
  // Create routes from internet to each virtual network.
  const vNetNodeKeys: string[] = [];
  for (const vnet of services.index.withType(AzureVirtualNetwork)) {
    const vnetResult = services.convert.vnet(
      services,
      vnet,
      backboneOutboundKey,
      internetBackboneKey
    );
    const route = vnetResult.route;

    if (route.constraints && route.constraints.destinationIp) {
      vNetNodeKeys.push(route.constraints.destinationIp);
    }

    for (const route of vnetResult.publicRoutes.inbound) {
      internetRoutes.push(route);
    }

    for (const route of vnetResult.publicRoutes.outbound) {
      backboneOutboundRoutes.push(route);
    }
  }

  internetRoutes.push({
    destination: internetEndpointKey,
    constraints: {
      destinationIp: internetServiceTag,
    },
  });

  // Create internet backbone node
  services.nodes.add({
    friendlyName: internetBackboneKey,
    internal: true,
    key: internetBackboneKey,
    routes: internetRoutes,
  });

  // Create internet endpoint node
  services.nodes.add({
    friendlyName: internetFriendlyName,
    key: internetEndpointKey,
    routes: [
      {
        destination: internetBackboneKey,
      },
    ],
    endpoint: true,
  });

  //
  // Add final default outbound route for the backbone to internet
  //
  backboneOutboundRoutes.push({
    destination: internetBackboneKey,
  });

  //
  // Create outbound backbone node
  //
  services.nodes.add({
    internal: true,
    key: backboneOutboundKey,
    friendlyName: AzureBackboneFriendlyName,
    routes: backboneOutboundRoutes,
  });

  // Define a service tag for `Internet`, which is referenced in router rules
  // generated by converters like vNetConverter(). Azure defines `Internet` as
  // any ip addresses not in the ranges of the VNets.
  // See https://docs.microsoft.com/en-us/azure/virtual-network/service-tags-overview
  const sourceIp = `except ${vNetNodeKeys.join(',')}`;
  services.symbols.defineServiceTag(internetServiceTag, sourceIp);
}
